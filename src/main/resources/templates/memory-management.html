<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
  <meta charset="UTF-8">
  <link  rel="stylesheet" th:href="@{/bootstrap/css/bootstrap.min.css}">

  <title>Memory Management</title>
</head>
<body>
<h1 class="animate__animated animate__bounce d-flex justify-content-center mt-20rem">Welcome to operating Systems</h1>
<nav class=" animate__animated animate__backInDown navbar-dark bg-dark navbar navbar-expand-lg navbar-light bg-light
container shadow-lg p-3 mb-5  rounded ">
  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarText"
          aria-controls="navbarText" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>
  <div class="collapse navbar-collapse" id="navbarText">
    <ul  class="animate__animated animate__fadeIn animate__delay-1s navbar-nav mr-auto">
      <li class="nav-item">
        <a class="nav-link " th:href="@{/}">Home<span class="sr-only"></span></a>
      </li>
      <li class="nav-item">
        <a class="nav-link " th:href="@{/processor-process}">Processor and Processes</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" th:href="@{/process-sync-deadlocks}">Processor Synchronization and Deadlocks</a>
      </li>
      <li class="nav-item">
        <a class="nav-link active"   th:href="@{/memoryManagement}">Memory Management</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" th:href="@{/fileManagement}">File Management</a>
      </li>
      <li class="nav-item">
        <a class="nav-link" th:href="@{/osSecurityAndProtection}">OS Security and Protection</a>
      </li>
      <li class="nav-item">
        <a class="nav-link " th:href="@{/osSecurityAndProtectionII}">OS Security and Protection II</a>
      </li>
      <li class="nav-item">
        <a class="nav-link active" th:href="@{/linuxBasics}">Linux Basics</a>
      </li>
    </ul>
    <span class="navbar-text">
        </span>


  </div>
</nav>

<div class="animate__animated animate__backInDown container shadow-lg p-3 mb-5 bg-white rounded ">
  <h1>
    Memory Management
  </h1>
  <a th:href="@{documents/l4op.pdf}">Lecture Notes</a>
  <p class="animate__animated animate__fadeIn animate__delay-1s">
    Many memory-management schemes exist, reflecting
    various approaches, and the effectiveness of each
    algorithm varies with the situation.
    <br/>

    Selection of a memory-management scheme for a system
    depends on many factors, especially on the system’s
    hardware design.
    <br/>
    Memory consists of a large array of bytes, each with it
    own address.

    <br/>
    The CPU fetches instructions from memory according to
    the value of the program counter.

    <br./>The memory unit sees only a stream of memory
    addresses;
    <br/>
    • it does not know how they are generated (by the
    instruction counter, indexing, indirection, literal
    addresses, and so on)
    <br/>
    • or what they are for (instructions or data).
  </p>


</div>
<div class="animate__animated animate__backInDown container shadow-lg p-3 mb-5 bg-white rounded ">
  <h2>Address Binding</h2>
  <p>Usually, a program resides on a disk as a binary executable
    file. To run, the program must be brought into memory and
    placed within the context of a process, where it becomes
    eligible for execution on an available CPU.
    <br/>
    Most systems allow a user process to reside in any part of
    the physical memory.
    <br/>
    Classically, the binding of instructions and data to memory
    addresses can be done at any step along the way:
  </p>
  <dl>
    <dt>
      1. Compile time.
    </dt>
    <dd>
      If u know at compile time where the process will reside
      in memory, then absolute code can be generated.
      <br/>
      E.g., if you know that a user process will reside
      starting at location R, then the generated compiler
      code will start at that location and extend up from
      there.
      <br>
       If, at some later time, the starting location changes,
      then it will be necessary to recompile this code.
    </dd>
    <dt>
      2. Load Time
    </dt>
    <dd>
      • If it is not known at compile time where the process
      will reside in memory, then the compiler must generate
      relocatable code. </dd>
    <dt>
      3. Execution time
    </dt>
    <dd>If the process can be moved during its execution from
      one memory segment to another, then binding must
      be delayed until run time.</dd>
  </dl>
</div>

<div class="animate__animated animate__backInDown container shadow-lg p-3 mb-5 bg-white rounded ">
  <h2>Logical Vs Physical Memory</h2>
  <p>
    An address generated by the CPU is commonly referred to
    as a logical address
    <br/>
    Whereas an address seen by the memory unit—that is,
    the one loaded into the memory-address register of the
    memory—is commonly referred to as a physical address
    <br/>
    The set of all logical addresses generated by a program is a
    logical address space.

    <br/>
    So in a nut-shell software use logical or what is also called virtual memory
    while there is also the physical memory which hardware like
    the Memory management unit is the one that maps the logical /virtual
    addresses to the real address in the physical memory .

  </p>
</div>
<div class="animate__animated animate__backInDown container shadow-lg p-3 mb-5 bg-white rounded ">
  <h2>Talk About DLLs</h2>
  <p>
    DLL stands for dynamically linked libraries. These are libraries that are
    dynamically liked to use programs when the programs are ran.
  </p>
</div>
<div class="animate__animated animate__backInDown container shadow-lg p-3 mb-5 bg-white rounded ">
  <h2>Memory Allocation</h2>
  <p>
    If a process requests for memory yet there is not enough, the process
    is rejected and an error massage is sent or the process is put in a
    queue.
    Memory can be allocated to processes in three ways:
  </p>
  <dl>
    <dt>1. First fit</dt>
    <dd>Allocate the first hole that is big enough.
      Searching can start either at the beginning of the set
      of holes or at the location where the previous first-fit
      search ended. We can stop searching as soon as we find a free hole
      that is large enough.
    </dd>
    <dt>2 Best fit</dt>
    <dd>
      Allocate the smallest hole that is big enough.
      We must search the entire list, unless the list is ordered
      by size.
      This strategy produces the smallest leftover hole
    </dd>
    <dt>3. Worst fit</dt>
    <dd>
      Allocate the largest hole.
      Again, we must search the entire list, unless it is sorted
      by size.
      This strategy produces the largest leftover hole, which
      may be more useful than the smaller leftover hole
    </dd>
  </dl>
</div>
<div class="animate__animated animate__backInDown container shadow-lg p-3 mb-5 bg-white rounded ">
  <h2>Paging</h2>
  <p>
    The basic method for implementing paging involves
    breaking physical memory into fixed-sized blocks called
    frames & breaking logical memory into blocks of the same
    size called pages
    <br/>
    When a process is to be executed, its pages are loaded
    into any available memory frames from their source (a file
    system or the backing store).
  </p>
  <h4>Steps taken by MMU to translate logical addresses to Physical addresses</h4>
  <p>
    The following outlines the steps taken by the MMU to
    translate a logical address generated by the CPU to a
    physical address:
    1. Extract the page number p and use it as an index
    into the page table.
    2. Extract the corresponding frame number f from the
    page table.
    3. Replace the page number p in the logical address
    with the frame number
  </p>
</div>


<script src="https://unpkg.com/htmx.org@2.0.1" integrity="sha384-QWGpdj554B4ETpJJC9z+ZHJcA/i59TyjxEPXiiUgN2WmTyV5OEZWCD6gQhgkdpB/" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js" integrity="sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r" crossorigin="anonymous"></script>
<script th:src="@{/bootstrap/js/bootstrap.min.js}"></script>

</body>
</html>